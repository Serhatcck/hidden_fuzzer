package hidden_fuzzer

import (
	"fmt"
	"strconv"
)

type Fuzzer struct {
	MainUrl         string
	Wordlist        []string
	RootInformation Response
	FoundUrls       []FoundUrl
	Headers         map[string]string
	//Tmp             Response
	//Config             Config
	DuplicateIndexes []DuplicateIndexes
}

type DuplicateIndexes struct {
	Url     string
	Counter int
	Body    string
	Index   int
}

type FoundUrl struct {
	Response         Response
	Request          Request
	DuplicateIndexId int // for analyze end of method
}

func Run(config Config) (*Fuzzer, error) {
	fuzzer := Fuzzer{
		//Config: config,
	}

	var err error
	//Url check
	if isURL(config.Url) {
		fuzzer.MainUrl = config.Url
	}

	//is wordlist true
	wordlist, err := readFileLines(config.Wordlist)
	if err != nil {
		return nil, err
	}
	fuzzer.Wordlist = wordlist

	mainResp, err := doMainReq(fuzzer)
	if err != nil {
		return nil, err
	}

	fuzzer.RootInformation = *mainResp
	//fmt.Println(fuzzer)
	prosses(&fuzzer)
	return &fuzzer, nil
}

func doMainReq(fuzzer Fuzzer) (*Response, error) {

	mainResp, err := sendHTTPRequest(Request{
		URL:     fuzzer.MainUrl,
		Headers: fuzzer.Headers,
	})

	return mainResp, err

}

func prosses(fuzzer *Fuzzer) {
	for _, newUrl := range fuzzer.Wordlist {
		newUrl = makeUrl(fuzzer.MainUrl, newUrl)

		req := Request{
			URL:     newUrl,
			Headers: fuzzer.Headers,
		}
		tmpResponse, err := sendHTTPRequest(req)
		if err != nil {
			fmt.Println(err)
		}

		if MainCheck(fuzzer.RootInformation, *tmpResponse) {
			continue
		}

		stat, index := DuplicateCheck(*tmpResponse, fuzzer)
		if stat {
			continue
		}

		fuzzer.FoundUrls = append(fuzzer.FoundUrls, FoundUrl{
			Response:         *tmpResponse,
			Request:          req,
			DuplicateIndexId: index,
		})
		fmt.Println("Found" + req.URL + ": " + strconv.Itoa(tmpResponse.StatusCode))
	}
}




func process(fuzzer *Fuzzer) {
	writer := uilive.New()
	writer.Start()
	fmt.Println("Process Start")

	// Yavaşlatma işlemi için bir kanal oluştur
	slowDown := make(chan struct{})

	// Semaphor için bir kanal oluştur
	semaphore := make(chan struct{}, 50) // Aynı anda en fazla 50 istek

	// Gorutin sayısını takip etmek için bir kanal oluştur
	goroutineCountChan := make(chan int)

	// Bir saniyede oluşan toplam gorutin sayısını takip etmek için bir kanal oluştur
	goroutinesPerSecondChan := make(chan int)

	// Gorutin sayısını güncelleyen bir fonksiyon başlat
	go func() {
		var count int
		ticker := time.NewTicker(time.Second)
		defer ticker.Stop()
		for {
			select {
			case <-ticker.C:
				// Her bir saniyede bir toplam gorutin sayısını ekrana bas
				goroutinesPerSecondChan <- count
				// counter'ı sıfırla
				count = 0
			case delta := <-goroutineCountChan:
				// Gorutin sayısını güncelle
				count += delta
			}
		}
	}()

	// Gorutin sayısını takip etmek için bir değişken tanımla

	go func() {
		for {
			writer.Flush()

			fmt.Fprintln(writer, "Total goroutines per second:", <-goroutinesPerSecondChan)
		}
	}()

	for idx, newUrl := range fuzzer.Wordlist {
		//batch değerini dinamik olarak yapıp modu ona göre ayarlaman gerekir
		//batch değerini timer a göre dinamikleştirebilirsin
		//batch değerini dinamik olarak düzenlemek veri kaçırmana neden olmaz
		//wait gruplarla bu batch deki işlemler bittiğinde timer vs. kontrolü yap parametreleri güncelle
		if idx%100 == 0 {
			//wg.waid() # 100 isteğin bitmesini bekle
			//ticker kontrolünü yap.
		}
		newUrl = makeUrl(fuzzer.MainUrl, newUrl)
		req := Request{
			URL:     newUrl,
			Headers: fuzzer.Headers,
		}
		responseChan := make(chan *Response)

		// Semaphore'u kullanarak aynı anda belirli sayıda gorutin çalıştır
		semaphore <- struct{}{}
		go func() {
			defer func() {
				// İşlem tamamlandığında semaphore'ı serbest bırak
				<-semaphore
			}()

			// İstek gönderilmeden önce gorutin sayısını artır
			goroutineCountChan <- 1

			go sendHTTPRequestThread(req, responseChan, fuzzer.threshold, slowDown)

			// Eğer gorutin sayısı eşik değerini aşarsa, bir sinyal gönder ve yavaşlat
			select {
			case <-slowDown:
				time.Sleep(200 * time.Millisecond) // 200 salise yavaşlatma
			default:
				// Yavaşlatma sinyali gelmediyse devam et
			}

			// Yanıtı al
			resp := <-responseChan

			// Yanıtı işle
			if resp.Error != nil {
				fmt.Println(resp.Error)
				return
			}

			if MainCheck(fuzzer.RootInformation, *resp) {
				return
			}

			stat, index := DuplicateCheck(*resp, fuzzer)
			if stat {
				return
			}

			fuzzer.FoundUrls = append(fuzzer.FoundUrls, FoundUrl{
				Response:         *resp,
				Request:          req,
				DuplicateIndexId: index,
			})
			fmt.Println(req.URL + ": " + strconv.Itoa(resp.StatusCode))
			fmt.Println("")

		}()
		// Gorutin sayısını artır

	}
	// Bir saniyede oluşan toplam gorutin sayısını al ve ekrana bas

}







func prosses(fuzzer *Fuzzer, batchSize int) {
	timer := time.NewTimer(0) // Başlangıçta timer'ı başlat
	for i := 0; i < len(fuzzer.Wordlist); i += batchSize {
		var wg sync.WaitGroup
		wg.Add(batchSize) // Her bir grup için WaitGroup oluştur

		// BatchSize kadar işlemi aynı anda başlat
		for j := i; j < len(fuzzer.Wordlist) && j < i+batchSize; j++ {
			go func(newUrl string) {
				defer wg.Done() // İşlem tamamlandığında WaitGroup'u azalt

				newUrl = makeUrl(fuzzer.MainUrl, newUrl)
				fmt.Println(newUrl)
				req := Request{
					URL:     newUrl,
					Headers: fuzzer.Headers,
				}
				tmpResponse, err := sendHTTPRequest(req)
				if err != nil {
					fmt.Println(err)
					return
				}

				if MainCheck(fuzzer.RootInformation, *tmpResponse) {
					return
				}

				stat, index := DuplicateCheck(*tmpResponse, fuzzer)
				if stat {
					return
				}

				fuzzer.FoundUrls = append(fuzzer.FoundUrls, FoundUrl{
					Response:         *tmpResponse,
					Request:          req,
					DuplicateIndexId: index,
				})
				fmt.Println(req.URL + ": " + strconv.Itoa(tmpResponse.StatusCode))
			}(fuzzer.Wordlist[j])
		}

		wg.Wait() // Her bir grup işlemi tamamlanana kadar bekle

		// Bir sonraki grup işlemine geçmeden önce 1 saniye bekle
		select {
		case <-timer.C: // If 1 second passed
			timer.Reset(time.Second) // Reset the timer
		case <-time.After(time.Second): // If 1 second hasn't passed yet
			// Wait for 1 second
			//time.Sleep()
		}
	}
	timer.Stop() // Timer'ı durdur
}