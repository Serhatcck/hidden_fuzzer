package hidden_fuzzer

import (
	"fmt"
	"math/rand"
	"net/http"
	"strconv"
	"sync"
	"time"

	"github.com/gosuri/uilive"
)

type Fuzzer struct {
	MainUrl         string
	Wordlist        []string
	RootInformation Response
	FoundUrls       []FoundUrl
	Headers         map[string]string
	//Tmp             Response
	//Config             Config
	DuplicateIndexes      []DuplicateIndexes
	threshold             time.Duration
	maxConcurrentRequests int
	client                http.Client
	sleep                 bool
}

type DuplicateIndexes struct {
	Url     string
	Counter int
	Body    string
	Index   int
}

type FoundUrl struct {
	Response         Response
	Request          Request
	DuplicateIndexId int // for analyze end of method
}

func Run(config Config) (*Fuzzer, error) {
	fuzzer := Fuzzer{
		//Config: config,
		threshold:             1 * time.Second, // Örnek bir eşik (1 saniye)
		maxConcurrentRequests: 50,
	}

	var err error
	//Url check
	if isURL(config.Url) {
		fuzzer.MainUrl = config.Url
	}

	//is wordlist true
	wordlist, err := readFileLines(config.Wordlist)
	if err != nil {
		return nil, err
	}
	fuzzer.Wordlist = wordlist
	mainResp, err := doMainReq(fuzzer)
	if err != nil {
		return nil, err
	}

	fuzzer.RootInformation = *mainResp
	prosses(&fuzzer, 100)
	//fmt.Println(fuzzer.FoundUrls)
	return &fuzzer, nil
}

func doMainReq(fuzzer Fuzzer) (*Response, error) {

	mainResp, err := sendHTTPRequest(fuzzer.client, Request{
		URL:     fuzzer.MainUrl,
		Headers: fuzzer.Headers,
	})
	if mainResp.StatusCode == 403 {
		seed := time.Now().UnixNano()
		r := rand.New(rand.NewSource(seed))

		// Rastgele 5 karakterden oluşan bir dize oluştur
		var randomUrl = string(r.Intn(26)+65) + string(r.Intn(20)+65) + string(r.Intn(26)+65) + string(r.Intn(26)+65)
		newUrl := makeUrl(fuzzer.MainUrl, randomUrl)
		mainResp, err = sendHTTPRequest(fuzzer.client, Request{
			URL:     newUrl,
			Headers: fuzzer.Headers,
		})
		return mainResp, err
	} else {
		return mainResp, err
	}

}

func prosses(fuzzer *Fuzzer, bs int) {
	writer := uilive.New()
	writer.Start()
	mainBatchSize := 500
	batchSizeChan := make(chan int)
	failureChan := make(chan error)
	//sleepChan := make(chan bool)
	timer := time.NewTimer(0) // Başlangıçta timer'ı başlat

	//TO DO change batchSize from cli or analyze response time
	//Firstly use main req time
	go func() {
		for {
			batchSizeChan <- mainBatchSize
			writer.Flush()
			fmt.Fprintln(writer, "Total goroutines per second:", mainBatchSize)
			//fmt.Println(mainBatchSize)
		}
	}()

	/*go func() {
		for {
			select {
			case <-sleepChan:
				fmt.Println("test")
				failureCheck(*fuzzer, 0)
				mainBatchSize = mainBatchSize - 10
			}
		}
	}()*/

	var wg sync.WaitGroup // WaitGroup döngü dışında tanımlanır
	// TO DO add fuzzing paths for this paths and add redirect this pats
	// TO DO add analyze function
	for idx := range fuzzer.Wordlist {

		batchSize := <-batchSizeChan
		if idx%batchSize == 0 {
			wgGroupSize := batchSize
			total := (idx + batchSize)
			if total > len(fuzzer.Wordlist) {
				wgGroupSize = len(fuzzer.Wordlist) - idx
			}

			wg.Add(wgGroupSize) // Her grup için iş parçacığı eklenir

			//fmt.Println(wgGroupSize)
			for indis := idx; indis < idx+wgGroupSize; indis++ {

				//writer.Flush()
				//fmt.Fprintln(writer, ": ", idx)

				//fmt.Println(strconv.Itoa(wgGroupSize) + " /// " + strconv.Itoa(indis))
				//fmt.Println(indis)
				go func(newUrl string) {
					defer wg.Done()

					runReq(newUrl, fuzzer, failureChan)

				}(fuzzer.Wordlist[indis])

			}

			wg.Add(1)
			go func() {
				defer wg.Done()
				//var wgFailure sync.WaitGroup // WaitGroup döngü dışında tanımlanır
				for {
					// her bir fail geldiğinde burası çalışıyor bunu düzelt
					// farklı bir chan oluştur fail geldiğinde ilk oraya gitsin bu chan boş mu dolu mu diye baksın boş ise buraya girmesin
					// gorutine asenkron çalıştığı için aynı anda 50 tane failure geliyor.
					select {
					case err := <-failureChan:
						fmt.Println(err)
					//time.Sleep(2000)
					/*if !fuzzer.sleep {

					}
					if !<-sleepChan {
						sleepChan <- true
					}*/
					default:
						//return
					}
				}
			}()

			wg.Wait() // Her grup için iş parçacıklarının tamamlanmasını bekler

			select {
			case <-timer.C: // If 1 second passed
				timer.Reset(time.Second) // Reset the timer
			case <-time.After(time.Second): // If 1 second hasn't passed yet
				// Wait for 1 second
			}
		}
	}
	timer.Stop() // Timer'ı durdur
	analyzeDuplicate(fuzzer)
}

func failureCheck(fuzzer Fuzzer, indis int) {

	/*if indis > 5 {
		fmt.Println("5 kere failure check denendi 5.den sonra yanıt alınamadı. ")
		//os.Exit(0)
	}*/
	time.Sleep(1000)
	_, err := sendHTTPRequest(fuzzer.client, Request{
		URL:     fuzzer.MainUrl,
		Headers: fuzzer.Headers,
	})

	if err != nil {
		failureCheck(fuzzer, indis+1)
	} else {
		fmt.Println("failure check end")
		//wg.Done()
	}

}

func analyzeDuplicate(fuzzer *Fuzzer) {
	newUrls := []FoundUrl{}
	for _, url := range fuzzer.FoundUrls {
		for _, duplicate := range fuzzer.DuplicateIndexes {

			if duplicate.Index == url.DuplicateIndexId {

				if duplicate.Counter <= 3 {
					newUrls = append(newUrls, url)
				}
			}
		}
	}
	fuzzer.FoundUrls = newUrls
}

func runReq(newUrl string, fuzzer *Fuzzer, failureChan chan error) {

	newUrl = makeUrl(fuzzer.MainUrl, newUrl)

	req := Request{
		URL:     newUrl,
		Headers: fuzzer.Headers,
	}
	tmpResponse, err := sendHTTPRequest(fuzzer.client, req)
	if err != nil {
		failureChan <- err
		return
	}

	if MainCheck(fuzzer.RootInformation, *tmpResponse) {
		return
	}

	stat, index := DuplicateCheck(*tmpResponse, fuzzer)
	if stat {
		return
	}

	fuzzer.FoundUrls = append(fuzzer.FoundUrls, FoundUrl{
		Response:         *tmpResponse,
		Request:          req,
		DuplicateIndexId: index,
	})
	fmt.Println(req.URL + ": " + strconv.Itoa(tmpResponse.StatusCode))
}

/*
func sendHTTPRequestThread(request Request, responseChan chan<- *Response, threshold time.Duration, slowDown chan struct{}) {
	start := time.Now()
	//fmt.Println(request.URL)
	req, err := http.NewRequest("GET", request.URL, nil)
	if err != nil {
		responseChan <- &Response{Error: err}
		return
	}

	for key, value := range request.Headers {
		req.Header.Set(key, value)
	}
	//clientleri tek bir connectiona düşür ve tüm istekleri bu connection üzerinden gönder.
	client := &http.Client{}
	resp, err := client.Do(req)

	if err != nil {
		responseChan <- &Response{Error: err}
		return
	}
	defer resp.Body.Close()

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		responseChan <- &Response{Error: err}
		return
	}

	duration := time.Since(start)
	if duration > threshold {
		// Eğer yanıt süresi eşiğin üzerindeyse, slowDown kanalına sinyal gönderiyoruz.
		slowDown <- struct{}{}
	}

	bodySmilar := string(data)
	responseChan <- &Response{
		URL:            request.URL,
		StatusCode:     resp.StatusCode,
		Headers:        resp.Header,
		Body:           string(data),
		ContentLength:  resp.ContentLength,
		ContentType:    resp.Header.Get("Content-Type"),
		Time:           time.Since(start),
		DataForSimilar: bodySmilar,
	}

}*/
